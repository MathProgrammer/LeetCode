For simplification, let us simply find the count of all good integers < N + 1 

There are two types of good integers. 

1. Those with fewer digits 
2. Those with the same number of digits. 

We will handle the first case of fewer digits (or 0 prefix) separately. 

Now, let us say there are only d digits. The number of good integers is 9^d. 
We can find the number of good integers like this. 

----

In order to count the number of integers with the same number of digits, 
we will iterate over every possible prefix. 

1. Some prefix will be equal 
2. For some digit, n[d] < N[d] 
3. The suffix can be chosen freely 

We will iterate over the length of the equal prefix and then count the number of ways of 
choosing the suffix. 

There are N[d] - 1 ways of choosing the first smaller digit. 
The suffix can be chosen in (9^suffix) ways 

Clearly, if we have a 0, then we must stop as we cannot have 0 in the prefix of any good integer. 

-----

class Solution 
{
    private: 
    long long power(long long x, long long p)
    {
        long long answer = 1; 
        while(p > 0)
        {
            answer *= x; 
            p--;
        }

        return answer;
    }
    
    long long countDistinctTill(string &N)
    {
        //cout << "N = " << N << "\n";
        long long count = 0; 
        for(int d = 1; d < N.size(); d++)
        {
            long long d_digit_numbers = power(9, d);
            count += d_digit_numbers;
        }
        
        for(int d = 0; d < N.size(); d++)
        {
            if(N[d] == '0')
            {
                break;
            }

            long long choices_for_current = N[d] - '1';
            long long suffix = power(9, N.size() - d - 1);
            long long count_with_this_prefix = choices_for_current*suffix;
            //cout << "choices = " << choices_for_current << "\n";

            count += count_with_this_prefix;
        }
        
        return count;
    }

    string convert_to_string(long long n)
    {
        string N;
        while(n > 0)
        {
            int digit = n%10;
            N += (char)('0' + digit);
            n /= 10;
        }

        reverse(N.begin(), N.end());
        return N;
    }
    
    public:
    long long countDistinct(long long n) 
    {
        string N = convert_to_string(n + 1);
        return countDistinctTill(N);
    }
};