From a given cell (r, c) we have the following options 

1. Go one row up 
2. In the same row, go left. However, after that go up.
3. In the same row, go right. However after that go up.

-----

Let us compute the following 2 pieces of information for every cell 

1. No_of_ways_going_up_next - up_paths 
2. Total no of ways - no_of_ways = up_paths + left + right 

-----

Let us discuss how to count both of them. 

How to calculate up_paths[r][c] ? 

We can go to any cell of the form (r - 1, c') where 

square(1) + square(c' - c) <= square(d) 

Let the smallest possible c' be L and largest be R 

up_path[r][c] = no_of_path[r - 1][L] + no_of_path[r - 1][L + 1] + ... + no_of_path[r - 1][R]

We can do this in a quick way by maintaining a prefix sum of each row in no_of_path. 

We can find out c' with binary search. Find the largest c' such that 

square(1) + square(c' - c) <= square(d) 

L = max(0, c - c')
R = min(columns - 1, c + c') 

Keep in mind that we are doing this because we can go c' steps in both directions - left and right 

------

Now, how to calculate no_oF_paths[r][c] ? 

We either go up, or L-up or R-up 

So, once we calculate up_paths for the entire row. 

Again, let c' be the largest c satisfying 

square(0) + square(c - c') <= square(d)

Calculate L and R like before.

No_of_paths[r][c] = up_paths[r][L] + up_path + [r][L + 1] + ... + up_path[r][R]

We can do this quickly by maintaining a prefix sum over up_path. 

-----

So, we need to do the following - 

1. Binary search to find the range of columns possible in the previous row. 
2. Binary search to find the range of columns in the same row. 
3. Separately store up_paths and total_paths 
4. Calculate up_paths first, and then no_of_paths

-----

class Solution {
    private: 
    int min(int x, int y)
    {
        return (x < y ? x : y);
    }
    
    int square(int n)
    {
        return n*n;
    }

    int get_c(int d, int r)
    {
        int left = 0, right = d + 1; 
        while(right - left > 1)
        {
            int mid = (left + right)/2; 
            if(square(mid) + square(r) <= square(d))
            {
                left = mid;
            }
            else 
            {
                right = mid;
            }
        }

        return left;
    }

    long long get_sum(vector <long long> &sum, int i, int c_range)
    {
        int left = max(0, i - c_range); 
        int right = min(sum.size() - 1, i + c_range);

        const int MOD = 1e9 + 7;
        long long range_sum = sum[right] - (left == 0 ? 0 : sum[left - 1]);
        range_sum += MOD; 
        range_sum %= MOD;
        
        return range_sum;
    }

public:
    int numberOfRoutes(vector<string>& grid, int d) 
    {
        const int MOD = 1e9 + 7;
        int rows = grid.size(), columns = grid[0].size(); 
        vector <vector <int> > up_paths(rows, vector <int> (columns, 0));
        vector <vector <int> > no_of_paths(rows, vector <int> (columns, 0));
        vector <vector <long long> > prefix_sum(rows, vector <long long> (columns, 0));
        vector <vector <long long> > prefix_sum_up(rows, vector <long long> (columns, 0));

        const char BLOCK = '#', FREE = '.';
        for(int r = 0; r < rows; r++)
        {
            for(int c = 0; c < columns; c++)
            {
                if(grid[r][c] == BLOCK)
                {
                    continue;
                }

                if(r == 0)
                {
                    up_paths[r][c] = 1;
                    continue;
                }

                int c_range = get_c(d, 1);
                up_paths[r][c] = get_sum(prefix_sum[r - 1], c, c_range);
            }

            for(int c = 0; c < columns; c++)
            {
                prefix_sum_up[r][c] = up_paths[r][c] + (c == 0 ? 0 : prefix_sum_up[r][c - 1]);
                prefix_sum_up[r][c] %= MOD;
            }

            for(int c = 0; c < columns; c++)
            {
                if(grid[r][c] == BLOCK)
                {
                    continue;
                }
                
                int c_range = get_c(d, 0);
                no_of_paths[r][c] = get_sum(prefix_sum_up[r], c, c_range);
            }

            for(int c = 0; c < columns; c++)
            {
                prefix_sum[r][c] = no_of_paths[r][c] + (c == 0 ? 0 : prefix_sum[r][c - 1]);
                prefix_sum[r][c] %= MOD;
            }
        }

        long long answer = prefix_sum[rows - 1][columns - 1];
        return answer;
    }
};