Let us reduce each integer to it's square free form. 
In it's square free form, the exponent of every prime factor is either 0 or 1
depending on it's parity in n. 

For an integer to be a square, every prime factor must have an even count. 

U x V is a perfect square, if square_free[u] = square_free[v] 
Their odd prime factors add up to an even exponent. 
Their even prime factors remain even. 

So we have to know the number of ancestors of each vertex such that 
it has the same square free value as nums[v]. 

----

In order to find out the square free version of each integer, we can do 
a modified sieve. 

For every integer, do a sieve to find it's largest prime factor. 
Check the exponent of it in n. 

square_free[n] = largest_prime_factor^{exponent mod 2} x square_free[n/p]

----

class Solution {
    private: 
    void sieve(vector <int> &square_free, int N)
    {
        vector <int> largest_prime_factor(N); 
        for(int i = 2; i < N; i++)
        {
            if(largest_prime_factor[i] != 0)
            {
                continue;
            }

            for(int multiple = i; multiple < N; multiple += i)
            {
                largest_prime_factor[multiple] = i;
            }
        }

        for(int i = 2; i < N; i++)
        {
            int current_i = i, exponent = 0, p = largest_prime_factor[i];
            while(current_i%p == 0)
            {
                current_i /= p; 
                exponent++;
            }

            square_free[i] = (exponent%2 == 1 ? p : 1)*square_free[current_i];
        }
    }

    long long dfs(
        vector <vector <int> > &tree, 
        int v, 
        int parent_v, 
        vector <int> &nums,
        vector <int> &square_free, 
        map <int, int> &frequency)
    {
        int squaree_free_v = square_free[nums[v]];
        long long answer_this_subtree = frequency[squaree_free_v];
        frequency[squaree_free_v]++;

        for(int child_v : tree[v])
        {
            if(child_v == parent_v)
            {
                continue;
            }

            answer_this_subtree += dfs(tree, child_v, v, nums, square_free, frequency);
        }

        frequency[squaree_free_v]--;
        return answer_this_subtree;
    }

public:
    long long sumOfAncestors(int n, vector<vector<int>>& edges, vector<int>& nums) {
        const int MAX_N = 1e5 + 5;
        vector <int> square_free(MAX_N, 1); 
        sieve(square_free, MAX_N);

        vector <vector <int> > tree(n + 1); 
        for(int i = 0; i < edges.size(); i++)
        {
            int u = edges[i][0], v = edges[i][1]; 
            tree[u].push_back(v); 
            tree[v].push_back(u);
        }

        map <int, int> frequency;
        long long sum = dfs(tree, 0, -1, nums, square_free, frequency); 

        return sum;
    }
};